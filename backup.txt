#include <graphics.h>
#include <iostream>
#include <vector>
#include <cstdlib>
#include <time.h>
#include <algorithm>
#include <cmath>
#include <math.h>
#include <stdio.h>
#include <map>
#include <float.h>
#include <set>
#define N_NODES 6
#define RADIUS 10
#define POP_SIZE 50
#define X_SIZE 640
#define Y_SIZE 480
#define RESISTENCE 0.9 // probability that mutate does not happen
#define TOP_BAR 30 // height in pixel of information bar


class GA{
    std::vector<int> node_x = std::vector<int>(N_NODES);
    std::vector<int> node_y = std::vector<int>(N_NODES);
    std::vector<std::vector<int>> population = std::vector<std::vector<int>>(POP_SIZE);
    std::vector<double> affinities = std::vector<double>(POP_SIZE);
    int best_one;
    public:

    void setup(){
	int gd = DETECT,gm;
        initgraph(&gd,&gm,NULL);
	setcolor(2);
    }

    void generate_graph(){
        for(int i=0; i<N_NODES; i++){
            node_x[i] = (rand() % (X_SIZE-RADIUS*2)) + RADIUS;
            node_y[i] = (rand() % (Y_SIZE-TOP_BAR-RADIUS*2)) + RADIUS + TOP_BAR;
        }
    }

    void print_graph(){
            for(int i=0; i<N_NODES; i++){
                circle(node_x[i], node_y[i], RADIUS);
	        char label[2]; // to convert label from int to char+NULL
	        sprintf(label, "%d", i);
                outtextxy(node_x[i]-RADIUS/2, node_y[i]-RADIUS/2, label);
            }
    }

    void generate_population(){
        for(int k=0; k<POP_SIZE; k++){
		std::vector<int> path = std::vector<int>(N_NODES);
		for(int i=0; i<N_NODES; i++)
		    path[i] = i;
		std::random_shuffle(path.begin(), path.end());
		population[k] = path;
	}
   }

    void print_best_one(int iteration){
	std::vector<int> best_path = population[best_one];
	for(int i=0; i<N_NODES-1; i++){
            line(node_x[best_path[i]], node_y[best_path[i]], node_x[best_path[i+1]], node_y[best_path[i+1]]);
	}
        char str[256]; // to convert label from int to char+NULL
        sprintf(str, "%lf", affinities[best_one]);
	//print affinity
	char affinity[] = "Affinity: ";
	outtextxy(30, 2, affinity);
	outtextxy(100, 2, str);
        sprintf(str, "%d", iteration);
	// print iterations
	char it[] = "Iterations: ";
	outtextxy(220, 2, it);
	outtextxy(320, 2, str);
	//print population size
	char population_size[] = "Population size: ";
        sprintf(str, "%d", POP_SIZE);
	outtextxy(410, 2, population_size);
	outtextxy(560, 2, str);
    }

    void calculate_affinities(){
	double sum = 0;
	double min = DBL_MAX;
        for(int k=0; k<POP_SIZE; k++){ // calculate score for every member of population
	    double score=0;
	    for(int i=0; i<N_NODES-1; i++){ // sum every distance of path
		score += sqrt(pow((node_x[population[k][i]] - node_x[population[k][i+1]]), 2) + pow((node_y[population[k][i]] - node_y[population[k][i+1]]), 2));
	    }
	    if(score<min){
		min = score;
		best_one = k;
	    }
	    affinities[k] = 1/(score+1); // invert score (shortest path are better), +1 to avoid crash
	    sum += affinities[k];
        }
	for(int i=0; i<POP_SIZE; i++){
	    affinities[i] = affinities[i]/sum;
	}
    }

    void reproduce(){
	std::vector<std::vector<int>> newborn = std::vector<std::vector<int>>(POP_SIZE);
	for(int i=0; i<POP_SIZE; i++)
		newborn[i] = crossover(pick_candidate());
	population = newborn;
    }

    int pick_candidate(){
	double r = ((double) rand() / (RAND_MAX));
	int i=0;
	while(r>0){
	    r -= affinities[i];
	    i++;
	}
	i--;
	return i;
    }

    std::vector<int> crossover(int a){ //TODO dad perde geni, riceve quelli di mom
	/*std::vector<int> dad = population[a];
	std::vector<int> mom = population[b];

	double i = rand()%N_NODES;
	double j = rand()%N_NODES;

	if(i>j){
	   double aux = i;
	   i = j;
	   j = aux;
	}
	std::set<int> removed;
	int l;
	for(l=0; l<j-i+1; l++) // iterate over parts to substitute
	    removed.insert(dad[i+l]);
	int h=0; //index over elements of
	for(k=0; k<l; k++){ // l is length of character to substitute
	    for(h=0; h<N_NODES; h++) // iterate over 

	}
	return population[a];*/
	int i = rand()%N_NODES;
	int j = rand()%N_NODES;
	int aux;
	std::vector<int> dad = population[a];

	double r = ((double) rand() / (RAND_MAX));
	if(r<RESISTENCE)
	     return dad;

	aux = dad[i];
	dad[i] = dad[j];
	dad[j] = aux;
	return dad;
    }
};

int main()
{
    srand(time(NULL));
    GA alg;
    alg.setup();
    alg.generate_graph();
    alg.generate_population();
    int i=0;
    while(true){
	    alg.calculate_affinities(); // after execution, affinities keep probability based on the length of the path
	    alg.reproduce();
	    cleardevice();
	    alg.print_graph();
    	    alg.print_best_one(i);
	    delay(200);
	    i++;	    
    }
    closegraph();
    return 0;
}
